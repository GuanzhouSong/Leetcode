#### Reference
* http://www.hawstein.com/posts/snake-ai.html


#### Step 1 
##### Simple Problem: 在一个矩形中，每一时刻有一个食物，贪吃蛇要在不撞到自己的条件下，找到一条路(未必要最优)，然后沿着这条路运行，去享用它的美食
* 我们先不去想蛇会越来越长这个事实，问题基本就是，给你一个起点(蛇头)和一个终点( 食物)，要避开障碍物(蛇身)，从起点找到一条可行路到达终点。
    * BFS
    * DFS
    * A*

* 只要有选择，就先选择最简单的方案，我们现在的目标是要让程序先跑起来， 优化是后话。so，从BFS开始。我们最初将蛇头位置放入队列，然后只要队列非空， 
就将队头位置出队，然后把它四领域内的4个点放入队列，不断地循环操作， 直到到达食物的位置。这个过程中，我们需要注意几点：
    * 1.访问过的点不再访问。
    * 2.保存每个点的父结点(即每个位置是从哪个位置走到它的， 这样我们才能把可行路径找出来)。
    * 3.蛇身所在位置和四面墙不可访问

#### Step 2
##### Problem is, if use BFS could not find the path to the food, what will the snake do ?
* could use the Wander function
    * 一个是在可行的范围内， 朝随机方向走随机步。也就是说，蛇每次运动的方向是随机出来的， 总共运动的步数也是随机的
    * Wander完之后，再去BFS一下，看能否吃到食物， 如果可以那就皆大欢喜了。如果不行，说明思考人生的时间还不够，再Wander一下。
    * 第二个版本的Wander函数，我就让贪吃蛇贪到底。在BFS无解后， 告诉蛇一个步数step(随机产生step)，让它在空白区域以S形运动step步。 
    这回运动方向就不随机了，而是有组织有纪律地运动。
    
#### Step 3
* 问题就出在蛇发现它自己和食物间有路径，就二话不说跑去吃食物了。 它没有考虑到，你这一去把食物给吃了后形成的局势(蛇身布局)， 
完全就可能让你挂掉。(比如进入了一个自己蛇身围起来的封闭小空间

#### Step 4
* 蛇和食物间有路径直接就去吃，不可取。那该怎么办？
* 如果蛇去吃食物后，布局是安全的，是否就直接去吃？(这样最优吗？)
* 怎样定义布局是否安全？
* 蛇和食物之间如果没有路径，怎么办？
* 最短路径是否最优？(这个明显不是了)
* 那么，如果布局安全的情况下，最短路径是否最优？
* 除了最短路径，我们还可以怎么走？S形？最长？
* 怎么应对蛇身越来越长这个问题？
* 食物是随机出现的，有没可能出现无解的布局？
* 暴力法(brute force)能否得到最优序列？(让贪吃蛇尽可能地多吃食物)

* 只要去想，问题还挺多的。这时让我们以面向过程的思想，带着上面的问题， 把思路理一理。一开始，蛇很短(初始化长度为1)，它看到了一个食物， 
使用BFS得到矩形中每个位置到达食物的最短路径长度。在没有蛇身阻挡下， 就是曼哈顿距离。然后，我要先判断一下，贪吃蛇这一去是否安全。 
所以我需要一条虚拟的蛇，它每次负责去探路。如果安全，才让真正的蛇去跑。 当然，虚拟的蛇是不会绘制出来的，它只负责模拟探路。
那么， 怎么定义一个布局是安全的呢？ 如果你把文章开头那张动态图片中蛇的销魂走位好好的看一下， 会发现即使到最后蛇身已经很长了，
它仍然没事一般地走出了一条路。而且， 是跟着蛇尾走的！嗯，这个其实不难解释，蛇在运动的过程中，消耗蛇身， 蛇尾后面总是不断地出现新的空间。
蛇短的时候还无所谓，当蛇一长， 就会发现，要想活下来，基本就只能追着蛇尾跑了。在追着蛇尾跑的过程中， 再去考虑能否安全地吃到食物。

OK，继续。真蛇派出虚拟蛇去探路后，发现吃完食物后的布局是安全的。那么， 真蛇就直奔食物了。等等，这样的策略好吗？未必。因为蛇每运动一步， 布局就变化一次。布局一变就意味着可能存在更优解。比如因为蛇尾的消耗， 原本需要绕路才能吃到的食物，突然就出现在蛇眼前了。所以，真蛇走一步后， 更好的做法是，重新做BFS。然后和上面一样进行安全判断，然后再走。

接下来我们来考虑一下，如果蛇和食物之间不存在路径怎么办？ 上文其实已经提到了做法了，跟着蛇尾走。只要蛇和食物间不存在路径， 蛇就一直跟着蛇尾走。同样的，由于每走一步布局就会改变， 所以每走一步就重新做BFS得到最新布局

好了，问题又来了。如果蛇和食物间不存在路径且蛇和蛇尾间也不存在路径， 怎么办？这个我是没办法了，选一步可行的路径来走就是了。还是一个道理， 每次只走一步，更新布局，然后再判断蛇和食物间是否有安全路径； 没有的话，蛇头和蛇尾间是否存在路径；还没有，再挑一步可行的来走。

1. 目标是食物时，走最短路径
2. 目标是蛇尾时，走最长路径


